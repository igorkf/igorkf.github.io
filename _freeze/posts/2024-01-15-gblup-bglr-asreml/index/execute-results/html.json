{
  "hash": "d46facea27d5529ced96cf0a82a717a2",
  "result": {
    "markdown": "---\ntitle: \"Comparing BGLR and asreml to fit GBLUP models in single and multi-environment trials\"\ndate: \"2024-01-15\"\ndate-modified: last-modified\ncategories: [R, GBLUP, BGLR, asreml]\ndraft: false\nbibliography: references.bib\nimage: images/wheat.jpg\n---\n\n\n# Introduction\n\nMostly, I have been using the package `asreml` [@asreml2023] for fitting genomic prediction models. This year I started to read some papers about fitting GBLUP models. For example, I read the reaction norm paper [@jarquin2014] and the `BGLR` package paper [@perez2014]. I noticed both papers used the `BGLR` package, so I wondered if I could get similar results with `asreml`. This post is an attempt to compare results from `BGLR` and `asreml` packages when fitting GBLUP models in single and multi-environment trials (MET).\n\n# Dataset\n\nTo compare both packages, we are going to use a MET dataset from the `BGLR` package, which comprises 599 historical CIMMYT wheat lines. The phenotypic trait is the average grain yield of these 599 wheat lines, evaluated in four environments. The trait was standardized to have null mean and unit variance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(BGLR) \nlibrary(asreml)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: Matrix\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nOnline License checked out Wed Jan 17 11:02:37 2024\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading ASReml-R version 4.2\n```\n:::\n:::\n\n\n# Single environment GBLUP\n\nThe first case is fitting a GBLUP for a single environment (here we consider the first).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(wheat, package = \"BGLR\")\n# ?wheat  # to know more about it\n\n# phenotypes\nwheat.Y <- as.data.frame(wheat.Y)\ncolnames(wheat.Y) <- paste0(\"y\", 1:4) \nrownames(wheat.Y) <- NULL \nwheat.Y$name <- as.factor(1:nrow(wheat.Y))  # fake genotype names \ny <- wheat.Y[, 1]  # get yield from first environment\nhead(wheat.Y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          y1          y2          y3         y4 name\n1  1.6716295 -1.72746986 -1.89028479  0.0509159    1\n2 -0.2527028  0.40952243  0.30938553 -1.7387588    2\n3  0.3418151 -0.64862633 -0.79955921 -1.0535691    3\n4  0.7854395  0.09394919  0.57046773  0.5517574    4\n5  0.9983176 -0.28248062  1.61868192 -0.1142848    5\n6  2.3360969  0.62647587  0.07353311  0.7195856    6\n```\n:::\n:::\n\n\nThe columns `y1` to `y4` represent the yield of each environment. I used fake numbers (1 to 599) to name each genotype in the column `name`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# markers\nX <- wheat.X \nn <- nrow(X) \np <- ncol(X)\ndim(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  599 1279\n```\n:::\n:::\n\n\nWe have 599 individuals and 1279 markers.\n\n# Cross-validation (CV)\n\nWe are going to evaluate the CV1 scheme (predicting unobserved genotypes), therefore 100 random genotypes will be hold as testing set. Remember, we are using the phenotypes from the first environment stored in `y`. In the `BGLR` package, we can mask the test set by setting the phenotypes to `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyNA <- y \nset.seed(123) \ntst <- sample(1:n, size = 100, replace = F)\nyNA[tst] <- NA\n```\n:::\n\n\nThe `tst` object holds integers that shows which rows are to be used as the testing set, and we are going to use them to calculate the test set accuracy.\n\n# Computing G matrix\n\nI am computing the genomic relationship matrix as described in the BGLR paper [@perez2014, see Box 9]:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- scale(X, center = T, scale = T)\nG <- (X %*% t(X)) / p  # same as tcrossprod(X) / p\nrownames(G) <- colnames(G) <- levels(wheat.Y$name)\ndim(G)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 599 599\n```\n:::\n\n```{.r .cell-code}\nG[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           1           2           3         4           5\n1 1.11819432  0.06109962  0.05387119 0.2473040  0.44643151\n2 0.06109962  1.44217931  1.42698671 0.1103435 -0.01189792\n3 0.05387119  1.42698671  1.44527589 0.1062722 -0.00525292\n4 0.24730400  0.11034351  0.10627223 0.8733090  0.22284413\n5 0.44643151 -0.01189792 -0.00525292 0.2228441  0.84811023\n```\n:::\n:::\n\n\n# GBLUP in BGLR\n\nFitting GBLUP in `BGLR` requires us to set a linear predictor (`ETA`).\\\nIn this case, we are using only one kernel, i.e., the covariance matrix `G`. If you want to check the iterations, set `verbose = T`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nETA <- list(list(K = G, model = \"RKHS\")) \nfm1 <- BGLR(y = yNA, ETA = ETA, nIter = 5000, burnIn = 1000, \n            saveAt = \"GBLUP_\", verbose = F) \npred_gblup_bglr <- data.frame(\n  name = wheat.Y[tst, \"name\"],\n  y = y[tst], \n  yhat = fm1$yHat[tst]\n) \ncor(pred_gblup_bglr$y, pred_gblup_bglr$yhat)  # correlation between observed and predicted values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5601514\n```\n:::\n:::\n\n\nNote: if you get a LAPACK error in Ubuntu, for example, try changing the defaults of BLAS and LAPACK [^1].\n\n[^1]: See section \"Selecting the default BLAS/LAPACK\" of the tutorial [Improving R Perfomance by installing optimized BLAS/LAPACK libraries](https://csantill.github.io/RPerformanceWBLAS)\n\n# GBLUP in asreml\n\nFitting GBLUP in `asreml` requires us to pass the covariance matrix `G` in the `vm` object. Now, we can just fit the model removing the testing samples with `wheat.Y[-tst, ]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod1 <- asreml(y1 ~ 1, random = ~ vm(name, source = G, singG = \"PSD\"), \n               data = wheat.Y[-tst, ]) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nASReml Version 4.2 17/01/2024 11:02:46\n          LogLik        Sigma2     DF     wall\n 1     -232.3355     0.8552212    498   11:02:47\n 2     -224.1149     0.7898886    498   11:02:47\n 3     -214.8656     0.6987314    498   11:02:47\n 4     -209.2359     0.6131716    498   11:02:47\n 5     -207.4308     0.5509318    498   11:02:47\n 6     -207.3177     0.5335289    498   11:02:47\n 7     -207.3163     0.5315242    498   11:02:47\n```\n:::\n\n```{.r .cell-code}\npred_gblup_asreml <- data.frame(\n  y = wheat.Y[tst, \"y1\"], \n  predict(mod1, classify = \"name\")$pvals[tst, c(\"name\", \"predicted.value\")]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nASReml Version 4.2 17/01/2024 11:02:47\n          LogLik        Sigma2     DF     wall\n 1     -207.3163     0.5313973    498   11:02:48\n 2     -207.3163     0.5313950    498   11:02:48\n 3     -207.3163     0.5313899    498   11:02:48\n```\n:::\n\n```{.r .cell-code}\ncor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5596302\n```\n:::\n:::\n\n\nComparing both packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp1 <- data.frame(\n  package = c(\"BGLR\", \"asreml\"), \n  varG = c(fm1$ETA[[1]]$varU, summary(mod1)$varcomp[1, \"component\"]),  \n  varE = c(fm1$varE, summary(mod1)$varcomp[2, \"component\"]),  \n  accuracy = c(cor(pred_gblup_bglr$y, pred_gblup_bglr$yhat),\n               cor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)))\ncomp1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  package      varG      varE  accuracy\n1    BGLR 0.5859860 0.5388088 0.5601514\n2  asreml 0.5736408 0.5315242 0.5596302\n```\n:::\n:::\n\n\nwhere `varG` is the genetic variance, `varE` is the residual variance, and `accuracy` is the Pearson's correlation between observed and predicted values (considering only the test set). The results are similar.\n\n\n::: {.cell fig.asp='1'}\n\n```{.r .cell-code}\npred <- merge(pred_gblup_bglr, pred_gblup_asreml, by = \"name\")\nplot(pred$yhat, pred$predicted.value, \n     xlab = \"BGLR predictions\", ylab = \"asreml predictions\")\nabline(coef = c(0, 1), col = \"blue\", lty = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=576}\n:::\n:::\n\n\n# MET GBLUP\n\nNow let's consider when we have more than one environment. This data has four.\n\nWe reshape the data from wide (four environments, one column per environment) to long (one column for all environments stacked).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwheat.Y.long <- reshape(wheat.Y, direction = \"long\", varying = 1:4, \n                        timevar = \"env\", sep = \"\")\nwheat.Y.long$id <- NULL \nrownames(wheat.Y.long) <- NULL \nwheat.Y.long$env <- as.factor(wheat.Y.long$env) \ndim(wheat.Y.long)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2396    3\n```\n:::\n\n```{.r .cell-code}\nhead(wheat.Y.long)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name env          y\n1    1   1  1.6716295\n2    2   1 -0.2527028\n3    3   1  0.3418151\n4    4   1  0.7854395\n5    5   1  0.9983176\n6    6   1  2.3360969\n```\n:::\n\n```{.r .cell-code}\ntail(wheat.Y.long)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name env         y\n2391  594   4 1.7915575\n2392  595   4 1.6596565\n2393  596   4 0.5543848\n2394  597   4 1.8487169\n2395  598   4 2.6928141\n2396  599   4 0.3813174\n```\n:::\n:::\n\n\nRemember, `name` are the genotypes, and `env` are the environments.\n\nNow we mask again, but now the response is in the long format. We will search for the rows where the genotypes were in the test set in the previous example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nylong <- wheat.Y.long[, \"y\"] \nylongNA <- ylong \nset.seed(123)\ntstlong <- as.integer(\n  rownames(wheat.Y.long[wheat.Y.long$name %in% wheat.Y[tst, \"name\"], ])\n) \nylongNA[tstlong] <- NA\nlength(tstlong)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 400\n```\n:::\n:::\n\n\n# MET BGLUP in BGLR\n\nAs the genotypes are repeated across environments, we need to expand the covariance matrix `G` to account for the repetitions. To do this, we perform $Z G Z ^{'}$, where $Z$ is the incidence matrix (also called design matrix) that connects genotypes to phenotypes, $G$ is the genetic relationship matrix, and $Z$ is the incidence matrix transposed, as explained in @jarquin2014.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nZ <- as.matrix(model.matrix(lm(y ~ name - 1, data = wheat.Y.long))) \nZGZt <- Z %*% G %*% t(Z) \ndim(ZGZt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2396 2396\n```\n:::\n:::\n\n\nNote that the $Z G Z^{'}$ matrix has dimension $n \\times n$, i.e., it matches the dimension of repeated genotypes across environments. You can play with `Z` to see how it looks like.\n\nNow we pass the kernel $Z G Z^{'}$ (instead of $G$) in the linear predictor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nETA <- list(list(K = ZGZt, model = \"RKHS\")) \nfm2 <- BGLR(y = ylongNA, ETA = ETA, nIter = 5000, burnIn = 1000, \n            saveAt = \"MET_BGLUP_\", verbose = F)\npred_gblup_bglr <- data.frame(\n  name = wheat.Y.long[tstlong, \"name\"],\n  env = wheat.Y.long[tstlong, \"env\"],\n  y = ylong[tstlong], \n  yhat = fm2$yHat[tstlong]\n) \ncor(pred_gblup_bglr$y, pred_gblup_bglr$yhat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3111166\n```\n:::\n:::\n\n\n# MET GBLUP in asreml\n\nIn `asreml` we can pass directly the $G$ matrix without expanding it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod2 <- asreml(y ~ 1, random = ~ vm(name, source = G, singG = \"PSD\"), \n               data = wheat.Y.long[-tstlong, ]) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nASReml Version 4.2 17/01/2024 11:03:38\n          LogLik        Sigma2     DF     wall\n 1     -902.1607     0.8549988   1995   11:03:38\n 2     -899.6476     0.8455182   1995   11:03:38\n 3     -897.4152     0.8330925   1995   11:03:38\n 4     -896.5900     0.8236879   1995   11:03:38\n 5     -896.4757     0.8190706   1995   11:03:39\n 6     -896.4751     0.8187290   1995   11:03:39\n```\n:::\n\n```{.r .cell-code}\np <- predict(mod2, classify = \"name\")$pvals[, c(\"name\", \"predicted.value\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nASReml Version 4.2 17/01/2024 11:03:39\n          LogLik        Sigma2     DF     wall\n 1     -896.4751     0.8187204   1995   11:03:39\n 2     -896.4751     0.8187203   1995   11:03:39\n 3     -896.4751     0.8187202   1995   11:03:39\n```\n:::\n\n```{.r .cell-code}\npred_gblup_asreml <- data.frame(\n  name = wheat.Y.long[tstlong, \"name\"], \n  env = wheat.Y.long[tstlong, \"env\"],\n  y = wheat.Y.long[tstlong, \"y\"]\n) \npred_gblup_asreml <- merge(pred_gblup_asreml, p, by = \"name\")\ncor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.311257\n```\n:::\n:::\n\n\nComparing both packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp2 <- data.frame(\n  package = c(\"BGLR\", \"asreml\"), \n  varG = c(fm2$ETA[[1]]$varU, summary(mod2)$varcomp[1, \"component\"]),  \n  varE = c(fm2$varE, summary(mod2)$varcomp[2, \"component\"]),  \n  accuracy = c(cor(pred_gblup_bglr$y, pred_gblup_bglr$yhat),\n               cor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)))\ncomp2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  package      varG      varE  accuracy\n1    BGLR 0.1736191 0.8177197 0.3111166\n2  asreml 0.1691422 0.8187290 0.3112570\n```\n:::\n:::\n\n\nThe results are similar.\n\n\n::: {.cell fig.asp='1'}\n\n```{.r .cell-code}\npred_met <- merge(pred_gblup_bglr, pred_gblup_asreml, by = c(\"name\", \"env\"))\nplot(pred_met$yhat, pred_met$predicted.value, \n     xlab = \"BGLR predictions\", ylab = \"asreml predictions\")\nabline(coef = c(0, 1), col = \"blue\", lty = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=576}\n:::\n:::\n\n\n# Conclusion\n\nIn both cases (single model and MET model), the `varG` differed a little bit among packages. I don't know why is that, but if you know I would be happy to see the explanation. Apart from that, the results are very similar.\n\nI hope you enjoyed this comparison! Let me know if you have any comments or issues.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=pt_BR.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=pt_BR.UTF-8        LC_COLLATE=pt_BR.UTF-8    \n [5] LC_MONETARY=pt_BR.UTF-8    LC_MESSAGES=pt_BR.UTF-8   \n [7] LC_PAPER=pt_BR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=pt_BR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Chicago\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] asreml_4.2.0.302 Matrix_1.6-3     BGLR_1.1.1      \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5        cli_3.6.2          knitr_1.45         rlang_1.1.3       \n [5] xfun_0.41          jsonlite_1.8.8     data.table_1.14.10 glue_1.7.0        \n [9] colorspace_2.1-0   htmltools_0.5.7    fansi_1.0.6        scales_1.3.0      \n[13] rmarkdown_2.25     grid_4.3.2         tibble_3.2.1       munsell_0.5.0     \n[17] evaluate_0.23      MASS_7.3-60.0.1    fastmap_1.1.1      yaml_2.3.8        \n[21] lifecycle_1.0.4    compiler_4.3.2     pkgconfig_2.0.3    htmlwidgets_1.6.4 \n[25] rstudioapi_0.15.0  truncnorm_1.0-9    lattice_0.22-5     digest_0.6.34     \n[29] R6_2.5.1           utf8_1.2.4         pillar_1.9.0       magrittr_2.0.3    \n[33] tools_4.3.2        gtable_0.3.4       ggplot2_3.4.4     \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}