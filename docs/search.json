[
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "Publications",
    "section": "",
    "text": "2022\n\nHeinemann, A. B., Costa-Neto, G., Fritsche-Neto, R., da Matta, D. H., & Fernandes, I. K. (2022). Enviromic prediction is useful to define the limits of climate adaptation: A case study of common bean in Brazil. Field Crops Research."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Igor Kuivjogi Fernandes",
    "section": "",
    "text": "Hey there! I’m Igor Kuivjogi Fernandes, a Graduate Research Assistant working at the Agricultural Statistics Lab of the University of Arkansas. My blog is a place where I share my thoughts and research papers with the world. Hope you enjoy reading them!"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "From the vibrant city of São Paulo in Brazil, I’m a Portuguese native speaker who now calls Arkansas home. I spent some time in the industry after high school before realizing my passion for statistics. This led me to pursue a Bachelor’s degree in Statistics from the Federal University of Goiás, where I served as an undergraduate researcher at Embrapa Rice and Beans 1. We used agricultural data to explore how environmental factors impacted the yield of rice and beans. This experience stimulated my interest in agricultural statistics, prompting me to pursue a Master’s degree in Statistics and Analytics from the University of Arkansas.\nStarted with C, then added R and Python to my toolkit. I’ve also used SQL in the past.\n\n\n\nFootnotes\n\n\nThe Brazilian Agricultural Research Corporation in charge of coordinating research and development of rice and beans, two crops that are extensively grown in Brazil.↩︎"
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "Igor Kuivjogi Fernandes",
    "section": "Recent posts",
    "text": "Recent posts\n\n\n\n\n\n\n\n\n\n\nComparing BGLR and asreml to fit GBLUP models in single and multi-environment trials\n\n\n6 min\n\n\n\n\n\n\nJan 15, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n\n See all"
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nComparing BGLR and asreml to fit GBLUP models in single and multi-environment trials\n\n\n6 min\n\n\n\n\n\n\nJan 15, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#recent-publications",
    "href": "index.html#recent-publications",
    "title": "Igor Kuivjogi Fernandes",
    "section": "Recent publications",
    "text": "Recent publications\n\n\n\n\n\n\n \n\n\n\nPublications\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Igor Kuivjogi Fernandes",
    "section": "Education",
    "text": "Education\n\n2023-present: MSc in Statistics and Analytics, University of Arkansas, U.S.\n2017-2022: BSc in Statistics, Federal University of Goiás, Brazil"
  },
  {
    "objectID": "posts/2023-03-20-block-effect-anova/index.html",
    "href": "posts/2023-03-20-block-effect-anova/index.html",
    "title": "Evaluating the block effect in ANOVA",
    "section": "",
    "text": "If you did a course in Experimental Design probably you heard about blocks. A famous quote seems to state it’s importance:\n\nBlock what you can, randomize what you cannot. 1\n\nIn this post I want to give you a practical look of how including a block term affects the results of ANOVA.\nAs we will be using a data structure called data.frame to store our experiment, I will remind you how to deal with such objects. As an illustration purpose, let’s work with the data frame mtcars. The object mtcars is a data frame with 32 observations and 11 variables. You can check its dimension in this way:\n\ndim(mtcars)\n\n[1] 32 11\n\n\nChecking the object type:\n\nclass(mtcars)\n\n[1] \"data.frame\"\n\n\nWe filter rows and columns using the syntax DATA[rows, cols]:\n\nmtcars[1, 1:2]  # first row, first two columns\n\n          mpg cyl\nMazda RX4  21   6\n\n\nAnother filtering:\n\nmtcars[5:10, 2:5]  # from 5th to 10th row, from 2nd to 5th column\n\n                  cyl  disp  hp drat\nHornet Sportabout   8 360.0 175 3.15\nValiant             6 225.0 105 2.76\nDuster 360          8 360.0 245 3.21\nMerc 240D           4 146.7  62 3.69\nMerc 230            4 140.8  95 3.92\nMerc 280            6 167.6 123 3.92\n\n\nNow that we know how to filter data frames, we can focus on our experiments with blocks. Before, let’s recap about some terms like experimental units, treatments, and randomization.\nLet’s say you work in a lab and the researchers want to evaluate the impact of using a new fertilizer on the yield of maize. You have available 12 plots (experimental units) and there are 3 different fertilizers (treatments), so each treatment level is replicated 4 times. As you might remember, we should randomly assign each treatment level to an experimental unit. This design is called Completely Randomized Design (CRD).\nFirst we create a data.frame with all possible treatment levels:\n\ndata <- data.frame(treatment = as.factor(c('A', 'B', 'C')))\ndata\n\n  treatment\n1         A\n2         B\n3         C\n\n\nWe repeat the data 4 times:\n\ndata <- rbind(data, data, data, data)\ndata\n\n   treatment\n1          A\n2          B\n3          C\n4          A\n5          B\n6          C\n7          A\n8          B\n9          C\n10         A\n11         B\n12         C\n\n\nNow randomly sort all the rows.\nThe sample function take a sample of a vector 1:nrow(data), i.e., 1:12. We use set.seed(NUMBER) so you can observe the same result as me:\n\nset.seed(123)\ndata$treatment <- data[sample(1:nrow(data)), 'treatment']  # randomize\ndata\n\n   treatment\n1          C\n2          C\n3          A\n4          B\n5          C\n6          B\n7          B\n8          A\n9          C\n10         B\n11         A\n12         A\n\n\nAs you can see, every treatment level was assigned to a random row (experimental unit). We can check the absolute frequency of treatment levels:\n\n# We use the `$` symbol to access a data frame column\ntable(data$treatment)\n\n\nA B C \n4 4 4 \n\n\nWe do have 4 replications per treatment level.\nAt this time, you could go to the field and do the job: plant maize in each plot, respecting your experiment.\nTo simulate a treatment effect, we will construct a new column in the data frame called yield. For the treatment A, the yield is low. For treatment B, the yield is moderate, and for treatment C the yield is high. For all the three cases, the yield will come from a normal distribution:\n\nset.seed(123)\n\n# low yield for treatment A\ndata[data$treatment == 'A', 'yield'] <- rnorm(n = 4, mean = 4, sd = 1)\n\n# moderate yield for treatment B\ndata[data$treatment == 'B', 'yield'] <- rnorm(n = 4, mean = 6, sd = 1)\n\n# high yield for treatment C\ndata[data$treatment == 'C', 'yield'] <- rnorm(n = 4, mean = 10, sd = 1)\n\nPlotting a boxplot:\n\nboxplot(yield ~ treatment, data = data)\n\n\n\n\nNow we can fit an ANOVA to check whether our treatment is significant using the aov function. We ask ANOVA to model yield as a function of the treatment variable and we check the results using the summary:\n\nmod <- aov(yield ~ treatment, data = data)\nsummary(mod)\n\n            Df Sum Sq Mean Sq F value   Pr(>F)    \ntreatment    2  71.86   35.93    34.5 6.02e-05 ***\nResiduals    9   9.37    1.04                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAs we expect, the fertilizer is significant (p-value \\(\\approx 6.9 \\times 10^{-5}\\)), because we simulate different yield scenarios regarding each fertilizer type.\nHowever, very often we know there is an underlying factor in the soil, for example, that could affect the yield. Here’s where block comes handy. In this experimental design known as Randomized Complete Block Design (RCBD), we include a block term in ANOVA to account for error control, assuming there exist subgroups of experimental units more similar within each block and less similar between each block.\n\nImagine that the 4 circles within the blue square are more homogeneous than between other blocks, so it makes sense to group them within the same block. The same goes for the other yellow and orange blocks. Applying to our example, each 4 experimental units would be within a block because we assume they are more similar within than between other blocks.\nThe first block could be affecting negatively our yield, whereas the second neutrally and the third positively. If we don’t account for blocks, then this underlying factor that is creating this “hidden” subgroups of experimental units could affect our ANOVA results.\n\n\n\n\nFootnotes\n\n\nBox, G. E., Hunter, W. H., & Hunter, S. (1978). Statistics for experimenters (Vol. 664). New York: John Wiley and sons.↩︎"
  },
  {
    "objectID": "posts/2024-01-14-gblup-bglr-asreml/gblup_bglr_asreml.html",
    "href": "posts/2024-01-14-gblup-bglr-asreml/gblup_bglr_asreml.html",
    "title": "Evaluating the block effect in ANOVA",
    "section": "",
    "text": "Introduction\nI have mostly used the package asreml for fitting genomic prediction models. This year I started a new project in my master’s degree, and I started to read some papers about fitting GBLUP models. For example, I read the reaction norm paper 1 and the BGLR package paper 2. I noticed both papers used the BGLR package, so I wondered: can I get the same results using both packages? This post in an attempt to get similar results using BGLR and asreml packages.\n\n\nDataset\nTo compare both packages, we are going to use a multi-environment trial dataset from the BGLR package, which comprises 599 historical CIMMYT wheat lines. The phenotypic trait is the average grain yield of these 599 wheat lines, evaluated in four environments. The trait was standardized to have null mean and unit variance.\n\nlibrary(BGLR) \nlibrary(asreml)\n\nCarregando pacotes exigidos: Matrix\n\n\nOnline License checked out Sun Jan 14 17:44:05 2024\n\n\nLoading ASReml-R version 4.2\n\ndata(wheat, package = \"BGLR\")\n# ?wheat  # to know more about it\n\n\n\nSingle environment GBLUP\nThe first case is fitting a GBLUP for the first environment.\n\nwheat.Y <- as.data.frame(wheat.Y) \ncolnames(wheat.Y) <- paste0(\"y\", 1:4) \nrownames(wheat.Y) <- NULL \nwheat.Y$name <- as.factor(1:nrow(wheat.Y))  # fake genotype names \ny <- wheat.Y[, 1]  # yield from first environment\nX <- wheat.X \nn <- nrow(X) \np <- ncol(X)\n\n\n\nconsidering CV1 (predicting 100 unobserved genotypes)\nyNA <- y set.seed(123) tst <- sample(1:n, size = 100, replace = F) yNA[tst] <- NA\n\n\ncomputing G matrix\nX <- scale(X, center = T, scale = T) G <- tcrossprod(X) / p # or (X %*% X) / p rownames(G) <- colnames(G) <- levels(wheat.Y$name)\n\n\n\n\n\nGBLUP\n\n\n\n\n\nGBLUP in BGLR\nETA <- list(list(K = G, model = “RKHS”)) fm1 <- BGLR(y = yNA, ETA = ETA, nIter = 5000, burnIn = 1000, saveAt = “RKHS_”) pred_gblup_bglr <- data.frame(y = y[tst], yhat = fm1\\(yHat[tst]) cor(pred_gblup_bglr\\)y, pred_gblup_bglr\\(yhat) plot(pred_gblup_bglr\\)y, pred_gblup_bglr$yhat)\n\n\nGBLUP in asreml\nmod1 <- asreml(y1 ~ 1, random = ~ vm(name, source = G, singG = “PSD”), data = wheat.Y[-tst, ]) pred_gblup_asreml <- data.frame(y = wheat.Y[tst, “y1”], yhat = summary(mod1, coef = T)\\(coef.random[tst, \"solution\"]) cor(pred_gblup_asreml\\)y, pred_gblup_asreml$yhat)\n\n\ncomparison\ndata.frame(models = c(“BGLR”, “asreml”), varG = c(fm1\\(ETA[[1]]\\)varU, summary(mod1)\\(varcomp[1, \"component\"]), varE = c(fm1\\)varE, summary(mod1)\\(varcomp[2, \"component\"]), accuracy = c(cor(pred_gblup_bglr\\)y, pred_gblup_bglr\\(yhat), cor(pred_gblup_asreml\\)y, pred_gblup_asreml$yhat)))\n\n\n\n\n\nMET GBLUP\n\n\n\n\n\nMET GBLUP in BGLR\nwheat.Y.long <- reshape(wheat.Y, direction = “long”, varying = 1:4, timevar = “env”, sep = ““) wheat.Y.long\\(id <- NULL rownames(wheat.Y.long) <- NULL wheat.Y.long\\)env <- as.factor(wheat.Y.long$env) dim(wheat.Y.long)\n\n\nCV1 (using the name sampled genoypes as GBLUP example)\nylong <- wheat.Y.long[, “y”] ylongNA <- ylong set.seed(123) tstlong <- as.integer(rownames(wheat.Y.long[wheat.Y.long$name %in% wheat.Y[tst, “name”], ])) ylongNA[tstlong] <- NA\n\n\nMET BGLUP in BGLR\nZ1 <- as.matrix(model.matrix(lm(y ~ name - 1, data = wheat.Y.long))) ZGZt <- Z1 %% G %% t(Z1) dim(ZGZt)\nETA <- list(list(K = ZGZt, model = “RKHS”)) fm2 <- BGLR(y = ylongNA, ETA = ETA, nIter = 5000, burnIn = 1000, saveAt = “RKHS_”) pred_gblup_bglr <- data.frame(y = ylong[tstlong], yhat = fm2\\(yHat[tstlong]) cor(pred_gblup_bglr\\)y, pred_gblup_bglr\\(yhat) plot(pred_gblup_bglr\\)y, pred_gblup_bglr$yhat)\n\n\nMET GBLUP in asreml\nmod2 <- asreml(y ~ 1, random = ~ vm(name, source = G, singG = “PSD”), data = wheat.Y.long[-tstlong, ]) pred_gblup_asreml <- data.frame(name = wheat.Y.long[tstlong, “name”], y = wheat.Y.long[tstlong, “y”]) blups <- summary(mod2, coef = T)\\(coef.random[, \"solution\"] blups <- data.frame(name = as.factor(gsub(\"[^0-9]\", \"\", names(blups))), yhat = unname(blups)) pred_gblup_asreml <- merge(pred_gblup_asreml, blups, by = \"name\") cor(pred_gblup_asreml\\)y, pred_gblup_asreml$yhat)\n\n\ncomparisons\ndata.frame(models = c(“BGLR”, “asreml”), varG = c(fm2\\(ETA[[1]]\\)varU, summary(mod2)\\(varcomp[1, \"component\"]), varE = c(fm2\\)varE, summary(mod2)\\(varcomp[2, \"component\"]), accuracy = c(cor(pred_gblup_bglr\\)y, pred_gblup_bglr\\(yhat), cor(pred_gblup_asreml\\)y, pred_gblup_asreml$yhat)))\n\n\n\n\n\nMET GBLUP with ECs\n\n\n\n\n\nsimulating 15 ECs\nset.seed(123) ECs <- matrix(0, nrow = length(levels(wheat.Y.long\\(env)), ncol = 15) colnames(ECs) <- as.factor(paste0(\"e\", 1:15)) for (j in 1:15) { ECs[, j] <- rnorm(4) } dataECs <- as.data.frame(ECs) dataECs\\)env <- as.factor(1:4) wheat.Y.long.ecs <- merge(wheat.Y.long, dataECs, by = “env”) boxplot(y ~ env, data = wheat.Y.long.ecs)\n\n\nMET BGLUP with ECs in BGLR\nW <- ECs %% t(ECs) / ncol(ECs) # relationship matrix of environments rownames(W) <- colnames(W) <- levels(wheat.Y.long.ecs$env) Z2 <- model.matrix(lm(y ~ env - 1, data = wheat.Y.long.ecs)) # incidence matrix of env ZWZt <- Z2 %% W %*% t(Z2) dim(ZWZt)\nETA <- list(list(KG = ZGZt, model = “RKHS”), list(KW = ZWZt, model = “RKHS”)) all(ylong == wheat.Y.long.ecs\\(y) fm3 <- BGLR(y = ylongNA, ETA = ETA, nIter = 5000, burnIn = 1000, saveAt = \"RKHS_\") pred_gblup_bglr <- data.frame(y = ylong[tstlong], yhat = fm3\\)yHat[tstlong]) cor(pred_gblup_bglr\\(y, pred_gblup_bglr\\)yhat)\nplot(pred_gblup_bglr\\(y, pred_gblup_bglr\\)yhat)\n\n\nMET GBLUP with ECs in asreml\nmod3 <- asreml(y ~ 1, random = ~ vm(name, source = G, singG = “PSD”) + vm(env, source = W, sing = “PSD”), data = wheat.Y.long.ecs[-tstlong, ]) pred_gblup_asreml <- data.frame(name = wheat.Y.long.ecs[tstlong, “name”], y = wheat.Y.long.ecs[tstlong, “y”]) blups <- summary(mod3, coef = T)\\(coef.random[, \"solution\"] blups <- blups[5:length(blups)] # drop env effects blups <- data.frame(name = as.factor(gsub(\"[^0-9]\", \"\", names(blups))), yhat = unname(blups)) pred_gblup_asreml <- merge(pred_gblup_asreml, blups, by = \"name\") cor(pred_gblup_asreml\\)y, pred_gblup_asreml$yhat)\n\n\ncomparisons\ndata.frame(models = c(“BGLR”, “asreml”), varG = c(fm3\\(ETA[[1]]\\)varU, summary(mod3)\\(varcomp[2, \"component\"]), varW = c(fm3\\)ETA[[2]]\\(varU, summary(mod3)\\)varcomp[1, “component”]), varE = c(fm3\\(varE, summary(mod3)\\)varcomp[3, “component”]), accuracy = c(cor(pred_gblup_bglr\\(y, pred_gblup_bglr\\)yhat), cor(pred_gblup_asreml\\(y, pred_gblup_asreml\\)yhat)))\n\n\n\n\n\nFootnotes\n\n\nJarquín, D., Crossa, J., Lacaze, X. et al. A reaction norm model for genomic selection using high-dimensional genomic and environmental data. Theor Appl Genet 127, 595–607 (2014). https://doi.org/10.1007/s00122-013-2243-1↩︎\nPaulino Pérez, Gustavo de los Campos, Genome-Wide Regression and Prediction with the BGLR Statistical Package, Genetics, Volume 198, Issue 2, 1 October 2014, Pages 483–495, https://doi.org/10.1534/genetics.114.164442↩︎"
  },
  {
    "objectID": "posts/2024-01-14-gblup-bglr-asreml/index.html",
    "href": "posts/2024-01-14-gblup-bglr-asreml/index.html",
    "title": "Comparing BGLR and asreml to fit GBLUP in single and multi-environment trials",
    "section": "",
    "text": "Introduction\nI have mostly used the package asreml for fitting genomic prediction models. This year I started to read some papers about fitting GBLUP models. For example, I read the reaction norm paper (Jarquín et al. 2014) and the BGLR package paper (Pérez and Campos 2014). I noticed both papers used the BGLR package, so I wondered if I could get similar results with asreml. This post is an attempt to compare results from BGLR and asreml packages when fitting GBLUP in single and multi-environment trials (MET).\n\n\nDataset\nTo compare both packages, we are going to use a MET dataset from the BGLR package, which comprises 599 historical CIMMYT wheat lines. The phenotypic trait is the average grain yield of these 599 wheat lines, evaluated in four environments. The trait was standardized to have null mean and unit variance.\n\nlibrary(BGLR) \nlibrary(asreml)\n\nCarregando pacotes exigidos: Matrix\n\n\nOnline License checked out Mon Jan 15 15:39:47 2024\n\n\nLoading ASReml-R version 4.2\n\n\n\n\nSingle environment GBLUP\nThe first case is fitting a GBLUP for a single environment (here we consider the first).\n\ndata(wheat, package = \"BGLR\")\n# ?wheat  # to know more about it\n\n# phenotypes\nwheat.Y <- as.data.frame(wheat.Y)\ncolnames(wheat.Y) <- paste0(\"y\", 1:4) \nrownames(wheat.Y) <- NULL \nwheat.Y$name <- as.factor(1:nrow(wheat.Y))  # fake genotype names \ny <- wheat.Y[, 1]  # get yield from first environment\nhead(wheat.Y)\n\n          y1          y2          y3         y4 name\n1  1.6716295 -1.72746986 -1.89028479  0.0509159    1\n2 -0.2527028  0.40952243  0.30938553 -1.7387588    2\n3  0.3418151 -0.64862633 -0.79955921 -1.0535691    3\n4  0.7854395  0.09394919  0.57046773  0.5517574    4\n5  0.9983176 -0.28248062  1.61868192 -0.1142848    5\n6  2.3360969  0.62647587  0.07353311  0.7195856    6\n\n\nThe columns y1 to y4 represent the yield of each environment. I used fake numbers (1 to 599) to name each genotype in the column name.\n\n# markers\nX <- wheat.X \nn <- nrow(X) \np <- ncol(X)\ndim(X)\n\n[1]  599 1279\n\n\nWe have 599 individuals and 1279 markers.\n\n\nCross-validation (CV)\nWe are going to evaluate the CV1 scheme (predicting unobserved genotypes), so 100 random genotypes will be left as testing set. Remember, we are using the phenotypes from the first environment stored in y. In the BGLR package, we can mask the test set by setting the phenotypes to NA:\n\nyNA <- y \nset.seed(123) \ntst <- sample(1:n, size = 100, replace = F)\nyNA[tst] <- NA\n\nThe tst object holds integers that shows which rows are to be used as the testing set.\n\n\nComputing G matrix\nI am computing the genomic relationship matrix as described in the BGLR paper (Pérez and Campos 2014, see Box 9):\n\nX <- scale(X, center = T, scale = T)\nG <- (X %*% t(X)) / p  # same as tcrossprod(X) / p\nrownames(G) <- colnames(G) <- levels(wheat.Y$name)\ndim(G)\n\n[1] 599 599\n\nG[1:5, 1:5]\n\n           1           2           3         4           5\n1 1.11819432  0.06109962  0.05387119 0.2473040  0.44643151\n2 0.06109962  1.44217931  1.42698671 0.1103435 -0.01189792\n3 0.05387119  1.42698671  1.44527589 0.1062722 -0.00525292\n4 0.24730400  0.11034351  0.10627223 0.8733090  0.22284413\n5 0.44643151 -0.01189792 -0.00525292 0.2228441  0.84811023\n\n\n\n\nGBLUP in BGLR\nFitting GBLUP in BGLR requires us to set a linear predictor (ETA).\nIn this case, we are using only one kernel, i.e., the covariance matrix G. If you want to check the iterations, set verbose = T.\n\nETA <- list(list(K = G, model = \"RKHS\")) \nfm1 <- BGLR(y = yNA, ETA = ETA, nIter = 5000, burnIn = 1000, saveAt = \"GBLUP_\", verbose = F) \npred_gblup_bglr <- data.frame(\n  name = wheat.Y[tst, \"name\"],\n  y = y[tst], \n  yhat = fm1$yHat[tst]\n) \ncor(pred_gblup_bglr$y, pred_gblup_bglr$yhat)  # correlation between observed and predicted values\n\n[1] 0.5601514\n\n\nNote: if you get an LAPACK error in Ubuntu, for example, try changing the defaults of BLAS and LAPACK 1.\n\n\nGBLUP in asreml\nFitting GBLUP in asreml requires us to pass the covariance matrix G in the vm object. Now, we can just fit the model removing the testing samples.\n\nmod1 <- asreml(y1 ~ 1, random = ~ vm(name, source = G, singG = \"PSD\"), \n               data = wheat.Y[-tst, ]) \n\nASReml Version 4.2 15/01/2024 15:39:56\n          LogLik        Sigma2     DF     wall\n 1     -232.3355     0.8552212    498   15:39:57\n 2     -224.1149     0.7898886    498   15:39:57\n 3     -214.8656     0.6987314    498   15:39:57\n 4     -209.2359     0.6131716    498   15:39:57\n 5     -207.4308     0.5509318    498   15:39:57\n 6     -207.3177     0.5335289    498   15:39:57\n 7     -207.3163     0.5315242    498   15:39:57\n\npred_gblup_asreml <- data.frame(\n  y = wheat.Y[tst, \"y1\"], \n  predict(mod1, classify = \"name\")$pvals[tst, c(\"name\", \"predicted.value\")]\n)\n\nASReml Version 4.2 15/01/2024 15:39:57\n          LogLik        Sigma2     DF     wall\n 1     -207.3163     0.5313973    498   15:39:58\n 2     -207.3163     0.5313950    498   15:39:58\n 3     -207.3163     0.5313899    498   15:39:58\n\ncor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)\n\n[1] 0.5596302\n\n\nComparing both packages:\n\ncomp1 <- data.frame(\n  package = c(\"BGLR\", \"asreml\"), \n  varG = c(fm1$ETA[[1]]$varU, summary(mod1)$varcomp[1, \"component\"]),  \n  varE = c(fm1$varE, summary(mod1)$varcomp[2, \"component\"]),  \n  accuracy = c(cor(pred_gblup_bglr$y, pred_gblup_bglr$yhat),\n               cor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)))\ncomp1\n\n  package      varG      varE  accuracy\n1    BGLR 0.5859860 0.5388088 0.5601514\n2  asreml 0.5736408 0.5315242 0.5596302\n\n\nwhere varG is the genetic variance, varE is the residual variance, and accuracy is the Pearson’s correlation between observed and predicted phenotypes (considering only the test set). The results are similar.\n\npred <- merge(pred_gblup_bglr, pred_gblup_asreml, by = \"name\")\nplot(pred$yhat, pred$predicted.value, \n     xlab = \"BGLR predictions\", ylab = \"asreml predictions\")\nabline(coef = c(0, 1), col = \"blue\", lty = 2)\n\n\n\n\n\n\nMET GBLUP\nNow let’s consider when we have more than one environment. This data has four.\nWe reshape the data from wide (four environments, one column per environment) to long (one column for all environments stacked).\n\nwheat.Y.long <- reshape(wheat.Y, direction = \"long\", varying = 1:4, timevar = \"env\", sep = \"\")\nwheat.Y.long$id <- NULL \nrownames(wheat.Y.long) <- NULL \nwheat.Y.long$env <- as.factor(wheat.Y.long$env) \ndim(wheat.Y.long)\n\n[1] 2396    3\n\nhead(wheat.Y.long)\n\n  name env          y\n1    1   1  1.6716295\n2    2   1 -0.2527028\n3    3   1  0.3418151\n4    4   1  0.7854395\n5    5   1  0.9983176\n6    6   1  2.3360969\n\ntail(wheat.Y.long)\n\n     name env         y\n2391  594   4 1.7915575\n2392  595   4 1.6596565\n2393  596   4 0.5543848\n2394  597   4 1.8487169\n2395  598   4 2.6928141\n2396  599   4 0.3813174\n\n\nRemember, name are the genotypes, and env are the environments.\nNow we mask again, but now the response in the long format. We will search for the rows where the genotypes were in the test set in the previous example.\n\nylong <- wheat.Y.long[, \"y\"] \nylongNA <- ylong \nset.seed(123)\ntstlong <- as.integer(rownames(wheat.Y.long[wheat.Y.long$name %in% wheat.Y[tst, \"name\"], ])) \nylongNA[tstlong] <- NA\nlength(tstlong)\n\n[1] 400\n\n\n\n\nMET BGLUP in BGLR\nAs the genotypes are repeated across environments, we need to expand the covariance matrix G to account for the repetitions. To do this, we perform \\(Z_1 G Z_1^{'}\\), where \\(Z_1\\) is the incidence matrix (also called design matrix) that connects genotypes to phenotypes, \\(G\\) is the genetic relationship matrix, and \\(Z_1\\) is the incidence matrix transposed, as explained in Jarquín et al. (2014).\n\nZ1 <- as.matrix(model.matrix(lm(y ~ name - 1, data = wheat.Y.long))) \nZGZt <- Z1 %*% G %*% t(Z1) \ndim(ZGZt)\n\n[1] 2396 2396\n\n\nNote that the \\(Z_1 G Z_1^{'}\\) is \\(n \\times n\\), i.e., it matches the dimension of repeated genotypes across environments. You can play with Z1 to see how it looks like.\nNow we pass the kernel \\(Z_1 G Z_1^{'}\\) (instead of \\(G\\)) in the linear predictor.\n\nETA <- list(list(K = ZGZt, model = \"RKHS\")) \nfm2 <- BGLR(y = ylongNA, ETA = ETA, nIter = 5000, burnIn = 1000, saveAt = \"MET_BGLUP_\", verbose = F)\npred_gblup_bglr <- data.frame(\n  name = wheat.Y.long[tstlong, \"name\"],\n  env = wheat.Y.long[tstlong, \"env\"],\n  y = ylong[tstlong], \n  yhat = fm2$yHat[tstlong]\n) \ncor(pred_gblup_bglr$y, pred_gblup_bglr$yhat)\n\n[1] 0.3111166\n\n\n\n\nMET GBLUP in asreml\nIn asreml we can pass directly the \\(G\\) matrix without expanding it.\n\nmod2 <- asreml(y ~ 1, random = ~ vm(name, source = G, singG = \"PSD\"), \n               data = wheat.Y.long[-tstlong, ]) \n\nASReml Version 4.2 15/01/2024 15:40:45\n          LogLik        Sigma2     DF     wall\n 1     -902.1607     0.8549988   1995   15:40:45\n 2     -899.6476     0.8455182   1995   15:40:45\n 3     -897.4152     0.8330925   1995   15:40:45\n 4     -896.5900     0.8236879   1995   15:40:45\n 5     -896.4757     0.8190706   1995   15:40:45\n 6     -896.4751     0.8187290   1995   15:40:45\n\nblups <- predict(mod2, classify = \"name\")$pvals[, c(\"name\", \"predicted.value\")]\n\nASReml Version 4.2 15/01/2024 15:40:46\n          LogLik        Sigma2     DF     wall\n 1     -896.4751     0.8187204   1995   15:40:46\n 2     -896.4751     0.8187203   1995   15:40:46\n 3     -896.4751     0.8187202   1995   15:40:46\n\npred_gblup_asreml <- data.frame(\n  name = wheat.Y.long[tstlong, \"name\"], \n  env = wheat.Y.long[tstlong, \"env\"],\n  y = wheat.Y.long[tstlong, \"y\"]\n) \npred_gblup_asreml <- merge(pred_gblup_asreml, blups, by = \"name\")\ncor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)\n\n[1] 0.311257\n\n\nComparing both packages:\n\ncomp2 <- data.frame(\n  package = c(\"BGLR\", \"asreml\"), \n  varG = c(fm2$ETA[[1]]$varU, summary(mod2)$varcomp[1, \"component\"]),  \n  varE = c(fm2$varE, summary(mod2)$varcomp[2, \"component\"]),  \n  accuracy = c(cor(pred_gblup_bglr$y, pred_gblup_bglr$yhat),\n               cor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)))\ncomp2\n\n  package      varG      varE  accuracy\n1    BGLR 0.1736191 0.8177197 0.3111166\n2  asreml 0.1691422 0.8187290 0.3112570\n\n\nThe results are similar.\n\npred_met <- merge(pred_gblup_bglr, pred_gblup_asreml, by = c(\"name\", \"env\"))\nplot(pred_met$yhat, pred_met$predicted.value, \n     xlab = \"BGLR predictions\", ylab = \"asreml predictions\")\nabline(coef = c(0, 1), col = \"blue\", lty = 2)\n\n\n\n\n\n\nConclusion\nIn both cases (single model and MET model), the varG differed a little bit among packages. I don’t know why is that, but if you know I would be happy to see the explanation. Apart from that, the results are very similar.\nI hope you enjoyed this comparison! Let me know if you have any comments or issues.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReferences\n\nJarquín, Diego, José Crossa, Xavier Lacaze, Philippe Du Cheyron, Joëlle Daucourt, Josiane Lorgeou, François Piraux, et al. 2014. “A Reaction Norm Model for Genomic Selection Using High-Dimensional Genomic and Environmental Data.” Theoretical and Applied Genetics 127 (3): 595–607. https://doi.org/10.1007/s00122-013-2243-1.\n\n\nPérez, Paulino, and Gustavo de los Campos. 2014. “Genome-Wide Regression and Prediction with the BGLR Statistical Package.” Genetics 198 (2): 483–95. https://doi.org/10.1534/genetics.114.164442.\n\nFootnotes\n\n\nSee section “Selecting the default BLAS/LAPACK” of the tutorial Improving R Perfomance by installing optimized BLAS/LAPACK libraries↩︎"
  },
  {
    "objectID": "posts/2024-01-15-gblup-bglr-asreml/index.html",
    "href": "posts/2024-01-15-gblup-bglr-asreml/index.html",
    "title": "Comparing BGLR and asreml to fit GBLUP models in single and multi-environment trials",
    "section": "",
    "text": "Introduction\nMostly, I have been using the package asreml (The VSNi Team 2023) for fitting genomic prediction models. This year I started to read some papers about fitting GBLUP models. For example, I read the reaction norm paper (Jarquín et al. 2014) and the BGLR package paper (Pérez and Campos 2014). I noticed both papers used the BGLR package, so I wondered if I could get similar results with asreml. This post is an attempt to compare results from BGLR and asreml packages when fitting GBLUP models in single and multi-environment trials (MET).\n\n\nDataset\nTo compare both packages, we are going to use a MET dataset from the BGLR package, which comprises 599 historical CIMMYT wheat lines. The phenotypic trait is the average grain yield of these 599 wheat lines, evaluated in four environments. The trait was standardized to have null mean and unit variance.\n\nlibrary(BGLR) \nlibrary(asreml)\n\nCarregando pacotes exigidos: Matrix\n\n\nOnline License checked out Mon Jan 15 18:01:40 2024\n\n\nLoading ASReml-R version 4.2\n\n\n\n\nSingle environment GBLUP\nThe first case is fitting a GBLUP for a single environment (here we consider the first).\n\ndata(wheat, package = \"BGLR\")\n# ?wheat  # to know more about it\n\n# phenotypes\nwheat.Y <- as.data.frame(wheat.Y)\ncolnames(wheat.Y) <- paste0(\"y\", 1:4) \nrownames(wheat.Y) <- NULL \nwheat.Y$name <- as.factor(1:nrow(wheat.Y))  # fake genotype names \ny <- wheat.Y[, 1]  # get yield from first environment\nhead(wheat.Y)\n\n          y1          y2          y3         y4 name\n1  1.6716295 -1.72746986 -1.89028479  0.0509159    1\n2 -0.2527028  0.40952243  0.30938553 -1.7387588    2\n3  0.3418151 -0.64862633 -0.79955921 -1.0535691    3\n4  0.7854395  0.09394919  0.57046773  0.5517574    4\n5  0.9983176 -0.28248062  1.61868192 -0.1142848    5\n6  2.3360969  0.62647587  0.07353311  0.7195856    6\n\n\nThe columns y1 to y4 represent the yield of each environment. I used fake numbers (1 to 599) to name each genotype in the column name.\n\n# markers\nX <- wheat.X \nn <- nrow(X) \np <- ncol(X)\ndim(X)\n\n[1]  599 1279\n\n\nWe have 599 individuals and 1279 markers.\n\n\nCross-validation (CV)\nWe are going to evaluate the CV1 scheme (predicting unobserved genotypes), therefore 100 random genotypes will be hold as testing set. Remember, we are using the phenotypes from the first environment stored in y. In the BGLR package, we can mask the test set by setting the phenotypes to NA:\n\nyNA <- y \nset.seed(123) \ntst <- sample(1:n, size = 100, replace = F)\nyNA[tst] <- NA\n\nThe tst object holds integers that shows which rows are to be used as the testing set, and we are going to use them to calculate the test set accuracy.\n\n\nComputing G matrix\nI am computing the genomic relationship matrix as described in the BGLR paper (Pérez and Campos 2014, see Box 9):\n\nX <- scale(X, center = T, scale = T)\nG <- (X %*% t(X)) / p  # same as tcrossprod(X) / p\nrownames(G) <- colnames(G) <- levels(wheat.Y$name)\ndim(G)\n\n[1] 599 599\n\nG[1:5, 1:5]\n\n           1           2           3         4           5\n1 1.11819432  0.06109962  0.05387119 0.2473040  0.44643151\n2 0.06109962  1.44217931  1.42698671 0.1103435 -0.01189792\n3 0.05387119  1.42698671  1.44527589 0.1062722 -0.00525292\n4 0.24730400  0.11034351  0.10627223 0.8733090  0.22284413\n5 0.44643151 -0.01189792 -0.00525292 0.2228441  0.84811023\n\n\n\n\nGBLUP in BGLR\nFitting GBLUP in BGLR requires us to set a linear predictor (ETA).\nIn this case, we are using only one kernel, i.e., the covariance matrix G. If you want to check the iterations, set verbose = T.\n\nETA <- list(list(K = G, model = \"RKHS\")) \nfm1 <- BGLR(y = yNA, ETA = ETA, nIter = 5000, burnIn = 1000, \n            saveAt = \"GBLUP_\", verbose = F) \npred_gblup_bglr <- data.frame(\n  name = wheat.Y[tst, \"name\"],\n  y = y[tst], \n  yhat = fm1$yHat[tst]\n) \ncor(pred_gblup_bglr$y, pred_gblup_bglr$yhat)  # correlation between observed and predicted values\n\n[1] 0.5601514\n\n\nNote: if you get an LAPACK error in Ubuntu, for example, try changing the defaults of BLAS and LAPACK 1.\n\n\nGBLUP in asreml\nFitting GBLUP in asreml requires us to pass the covariance matrix G in the vm object. Now, we can just fit the model removing the testing samples with wheat.Y[-tst, ].\n\nmod1 <- asreml(y1 ~ 1, random = ~ vm(name, source = G, singG = \"PSD\"), \n               data = wheat.Y[-tst, ]) \n\nASReml Version 4.2 15/01/2024 18:01:48\n          LogLik        Sigma2     DF     wall\n 1     -232.3355     0.8552212    498   18:01:48\n 2     -224.1149     0.7898886    498   18:01:48\n 3     -214.8656     0.6987314    498   18:01:48\n 4     -209.2359     0.6131716    498   18:01:48\n 5     -207.4308     0.5509318    498   18:01:49\n 6     -207.3177     0.5335289    498   18:01:49\n 7     -207.3163     0.5315242    498   18:01:49\n\npred_gblup_asreml <- data.frame(\n  y = wheat.Y[tst, \"y1\"], \n  predict(mod1, classify = \"name\")$pvals[tst, c(\"name\", \"predicted.value\")]\n)\n\nASReml Version 4.2 15/01/2024 18:01:49\n          LogLik        Sigma2     DF     wall\n 1     -207.3163     0.5313973    498   18:01:49\n 2     -207.3163     0.5313950    498   18:01:49\n 3     -207.3163     0.5313899    498   18:01:49\n\ncor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)\n\n[1] 0.5596302\n\n\nComparing both packages:\n\ncomp1 <- data.frame(\n  package = c(\"BGLR\", \"asreml\"), \n  varG = c(fm1$ETA[[1]]$varU, summary(mod1)$varcomp[1, \"component\"]),  \n  varE = c(fm1$varE, summary(mod1)$varcomp[2, \"component\"]),  \n  accuracy = c(cor(pred_gblup_bglr$y, pred_gblup_bglr$yhat),\n               cor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)))\ncomp1\n\n  package      varG      varE  accuracy\n1    BGLR 0.5859860 0.5388088 0.5601514\n2  asreml 0.5736408 0.5315242 0.5596302\n\n\nwhere varG is the genetic variance, varE is the residual variance, and accuracy is the Pearson’s correlation between observed and predicted values (considering only the test set). The results are similar.\n\npred <- merge(pred_gblup_bglr, pred_gblup_asreml, by = \"name\")\nplot(pred$yhat, pred$predicted.value, \n     xlab = \"BGLR predictions\", ylab = \"asreml predictions\")\nabline(coef = c(0, 1), col = \"blue\", lty = 2)\n\n\n\n\n\n\nMET GBLUP\nNow let’s consider when we have more than one environment. This data has four.\nWe reshape the data from wide (four environments, one column per environment) to long (one column for all environments stacked).\n\nwheat.Y.long <- reshape(wheat.Y, direction = \"long\", varying = 1:4, \n                        timevar = \"env\", sep = \"\")\nwheat.Y.long$id <- NULL \nrownames(wheat.Y.long) <- NULL \nwheat.Y.long$env <- as.factor(wheat.Y.long$env) \ndim(wheat.Y.long)\n\n[1] 2396    3\n\nhead(wheat.Y.long)\n\n  name env          y\n1    1   1  1.6716295\n2    2   1 -0.2527028\n3    3   1  0.3418151\n4    4   1  0.7854395\n5    5   1  0.9983176\n6    6   1  2.3360969\n\ntail(wheat.Y.long)\n\n     name env         y\n2391  594   4 1.7915575\n2392  595   4 1.6596565\n2393  596   4 0.5543848\n2394  597   4 1.8487169\n2395  598   4 2.6928141\n2396  599   4 0.3813174\n\n\nRemember, name are the genotypes, and env are the environments.\nNow we mask again, but now the response is in the long format. We will search for the rows where the genotypes were in the test set in the previous example.\n\nylong <- wheat.Y.long[, \"y\"] \nylongNA <- ylong \nset.seed(123)\ntstlong <- as.integer(\n  rownames(wheat.Y.long[wheat.Y.long$name %in% wheat.Y[tst, \"name\"], ])\n) \nylongNA[tstlong] <- NA\nlength(tstlong)\n\n[1] 400\n\n\n\n\nMET BGLUP in BGLR\nAs the genotypes are repeated across environments, we need to expand the covariance matrix G to account for the repetitions. To do this, we perform \\(Z G Z ^{'}\\), where \\(Z\\) is the incidence matrix (also called design matrix) that connects genotypes to phenotypes, \\(G\\) is the genetic relationship matrix, and \\(Z\\) is the incidence matrix transposed, as explained in Jarquín et al. (2014).\n\nZ <- as.matrix(model.matrix(lm(y ~ name - 1, data = wheat.Y.long))) \nZGZt <- Z %*% G %*% t(Z) \ndim(ZGZt)\n\n[1] 2396 2396\n\n\nNote that the \\(Z G Z^{'}\\) matrix has dimension \\(n \\times n\\), i.e., it matches the dimension of repeated genotypes across environments. You can play with Z to see how it looks like.\nNow we pass the kernel \\(Z G Z^{'}\\) (instead of \\(G\\)) in the linear predictor.\n\nETA <- list(list(K = ZGZt, model = \"RKHS\")) \nfm2 <- BGLR(y = ylongNA, ETA = ETA, nIter = 5000, burnIn = 1000, \n            saveAt = \"MET_BGLUP_\", verbose = F)\npred_gblup_bglr <- data.frame(\n  name = wheat.Y.long[tstlong, \"name\"],\n  env = wheat.Y.long[tstlong, \"env\"],\n  y = ylong[tstlong], \n  yhat = fm2$yHat[tstlong]\n) \ncor(pred_gblup_bglr$y, pred_gblup_bglr$yhat)\n\n[1] 0.3111166\n\n\n\n\nMET GBLUP in asreml\nIn asreml we can pass directly the \\(G\\) matrix without expanding it.\n\nmod2 <- asreml(y ~ 1, random = ~ vm(name, source = G, singG = \"PSD\"), \n               data = wheat.Y.long[-tstlong, ]) \n\nASReml Version 4.2 15/01/2024 18:02:35\n          LogLik        Sigma2     DF     wall\n 1     -902.1607     0.8549988   1995   18:02:36\n 2     -899.6476     0.8455182   1995   18:02:36\n 3     -897.4152     0.8330925   1995   18:02:36\n 4     -896.5900     0.8236879   1995   18:02:36\n 5     -896.4757     0.8190706   1995   18:02:36\n 6     -896.4751     0.8187290   1995   18:02:36\n\nblups <- predict(mod2, classify = \"name\")$pvals[, c(\"name\", \"predicted.value\")]\n\nASReml Version 4.2 15/01/2024 18:02:36\n          LogLik        Sigma2     DF     wall\n 1     -896.4751     0.8187204   1995   18:02:36\n 2     -896.4751     0.8187203   1995   18:02:37\n 3     -896.4751     0.8187202   1995   18:02:37\n\npred_gblup_asreml <- data.frame(\n  name = wheat.Y.long[tstlong, \"name\"], \n  env = wheat.Y.long[tstlong, \"env\"],\n  y = wheat.Y.long[tstlong, \"y\"]\n) \npred_gblup_asreml <- merge(pred_gblup_asreml, blups, by = \"name\")\ncor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)\n\n[1] 0.311257\n\n\nComparing both packages:\n\ncomp2 <- data.frame(\n  package = c(\"BGLR\", \"asreml\"), \n  varG = c(fm2$ETA[[1]]$varU, summary(mod2)$varcomp[1, \"component\"]),  \n  varE = c(fm2$varE, summary(mod2)$varcomp[2, \"component\"]),  \n  accuracy = c(cor(pred_gblup_bglr$y, pred_gblup_bglr$yhat),\n               cor(pred_gblup_asreml$y, pred_gblup_asreml$predicted.value)))\ncomp2\n\n  package      varG      varE  accuracy\n1    BGLR 0.1736191 0.8177197 0.3111166\n2  asreml 0.1691422 0.8187290 0.3112570\n\n\nThe results are similar.\n\npred_met <- merge(pred_gblup_bglr, pred_gblup_asreml, by = c(\"name\", \"env\"))\nplot(pred_met$yhat, pred_met$predicted.value, \n     xlab = \"BGLR predictions\", ylab = \"asreml predictions\")\nabline(coef = c(0, 1), col = \"blue\", lty = 2)\n\n\n\n\n\n\nConclusion\nIn both cases (single model and MET model), the varG differed a little bit among packages. I don’t know why is that, but if you know I would be happy to see the explanation. Apart from that, the results are very similar.\nI hope you enjoyed this comparison! Let me know if you have any comments or issues.\n\n\n\n\n\n\nReferences\n\nJarquín, Diego, José Crossa, Xavier Lacaze, Philippe Du Cheyron, Joëlle Daucourt, Josiane Lorgeou, François Piraux, et al. 2014. “A Reaction Norm Model for Genomic Selection Using High-Dimensional Genomic and Environmental Data.” Theoretical and Applied Genetics 127 (3): 595–607. https://doi.org/10.1007/s00122-013-2243-1.\n\n\nPérez, Paulino, and Gustavo de los Campos. 2014. “Genome-Wide Regression and Prediction with the BGLR Statistical Package.” Genetics 198 (2): 483–95. https://doi.org/10.1534/genetics.114.164442.\n\n\nThe VSNi Team. 2023. Asreml: Fits Linear Mixed Models Using REML. www.vsni.co.uk.\n\nFootnotes\n\n\nSee section “Selecting the default BLAS/LAPACK” of the tutorial Improving R Perfomance by installing optimized BLAS/LAPACK libraries↩︎"
  }
]